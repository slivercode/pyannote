# é—®é¢˜è¯Šæ–­ï¼šä¿æŒæ€»æ—¶é•¿åŠŸèƒ½æ— æ•ˆ

## ğŸ” é—®é¢˜æè¿°

**ç”¨æˆ·åé¦ˆ**ï¼š
- å¯ç”¨"ä¿æŒæ€»æ—¶é•¿ä¸å˜"åï¼Œè¾“å‡ºè§†é¢‘æ—¶é•¿æ²¡æœ‰å˜åŒ–
- æ— è®ºæ˜¯å¦å¯ç”¨æ™ºèƒ½åŠ é€Ÿï¼Œè¾“å‡ºéƒ½æ˜¯ 2:32 ç§’
- ä½†åŸå§‹SRTå­—å¹•æ€»æ—¶é•¿åªæœ‰ 1:55 ç§’
- æœŸæœ›ï¼šè¾“å‡ºè°ƒæ•´åçš„SRTæ–‡ä»¶ï¼ˆ1:55ç§’ï¼‰+ åŠ¨æ€åŠ é€Ÿçš„éŸ³é¢‘ï¼ˆ1:55ç§’ï¼‰

## ğŸ› æ ¹æœ¬åŸå› 

### é—®é¢˜1ï¼šTimelineAdjuster çš„é€»è¾‘é—®é¢˜

å½“å‰ `TimelineAdjuster` çš„é€»è¾‘ï¼š
```python
# è®¡ç®—åŸå§‹æ€»æ—¶é•¿
self.original_total_time = subtitles[-1]['end_ms']  # è¿™æ˜¯æœ€åä¸€å¥çš„ç»“æŸæ—¶é—´

# è°ƒæ•´æ—¶é—´è½´æ—¶
time_diff = total_actual_duration - self.original_total_time
```

**é—®é¢˜**ï¼š
- `subtitles[-1]['end_ms']` æ˜¯æœ€åä¸€å¥å­—å¹•çš„ç»“æŸæ—¶é—´ï¼ˆå¦‚ 1:55ï¼‰
- ä½†å®é™…é…éŸ³å¯èƒ½æ›´é•¿ï¼ˆå¦‚ 2:32ï¼‰
- `TimelineAdjuster` ä¼šå‹ç¼©é—´éš™ï¼Œä½†å¦‚æœé—´éš™ä¸å¤Ÿï¼Œå°±ä¼šè®©å­—å¹•ç´§å¯†æ’åˆ—
- **æœ€ç»ˆè¾“å‡ºçš„éŸ³é¢‘æ—¶é•¿ = æ‰€æœ‰é…éŸ³çš„å®é™…æ—¶é•¿**ï¼Œè€Œä¸æ˜¯ 1:55

### é—®é¢˜2ï¼šéŸ³é¢‘åŠ é€Ÿé€»è¾‘æœªæ­£ç¡®æ‰§è¡Œ

åœ¨ `_merge_audio_with_timeline` æ–¹æ³•ä¸­ï¼š
```python
# å¦‚æœéŸ³é¢‘æ—¶é•¿ä¸ç›®æ ‡æ—¶é•¿ä¸åŒ¹é…ï¼Œè¿›è¡Œè°ƒæ•´
if abs(audio_duration - target_duration) > 10:  # å…è®¸10msè¯¯å·®
    if audio_duration > target_duration:
        # éŸ³é¢‘å¤ªé•¿ï¼Œä½¿ç”¨FFmpegåŠ é€Ÿ
        speed_ratio = audio_duration / target_duration
```

**é—®é¢˜**ï¼š
- è¿™ä¸ªé€»è¾‘æ˜¯å¯¹çš„ï¼Œä½†åªæœ‰å½“ `target_duration < audio_duration` æ—¶æ‰ä¼šåŠ é€Ÿ
- å¦‚æœ `TimelineAdjuster` æ²¡æœ‰æ­£ç¡®å‹ç¼©æ—¶é—´è½´ï¼Œ`target_duration` å¯èƒ½ä»ç„¶ç­‰äº `audio_duration`
- ç»“æœï¼šæ²¡æœ‰è§¦å‘åŠ é€Ÿé€»è¾‘

## âœ… è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆ1ï¼šä¿®å¤ TimelineAdjusterï¼ˆæ¨èï¼‰

ä¿®æ”¹ `TimelineAdjuster` çš„é€»è¾‘ï¼Œç¡®ä¿ï¼š
1. è®¡ç®—é…éŸ³æ€»æ—¶é•¿
2. å¦‚æœé…éŸ³æ€»æ—¶é•¿ > åŸå§‹SRTæ€»æ—¶é•¿ï¼Œ**å¼ºåˆ¶åŠ é€Ÿæ¯æ®µé…éŸ³**
3. è°ƒæ•´åçš„æ—¶é—´è½´æ€»æ—¶é•¿ = åŸå§‹SRTæ€»æ—¶é•¿

### æ–¹æ¡ˆ2ï¼šä½¿ç”¨ SimpleTimelineBuilderï¼ˆæ›´ç®€å•ï¼‰

å¦‚æœä½ çš„éœ€æ±‚æ˜¯ï¼š
- ä»æŒ‡å®šåç§»å¼€å§‹ï¼ˆå¦‚ 00:00:07,000ï¼‰
- é¡ºåºæ’åˆ—é…éŸ³
- å¦‚æœè¶…å‡ºæ€»æ—¶é•¿ï¼Œè‡ªåŠ¨åŠ é€Ÿ

é‚£ä¹ˆåº”è¯¥ä½¿ç”¨ `SimpleTimelineBuilder` è€Œä¸æ˜¯ `TimelineAdjuster`ã€‚

## ğŸ”§ ä¿®å¤ä»£ç 

### ä¿®å¤ TimelineAdjuster

```python
def _compress_timeline(self, actual_durations: List[int], excess_time: int) -> List[Dict]:
    """
    å‹ç¼©æ—¶é—´è½´ï¼šé…éŸ³è¶…å‡ºåŸå§‹æ—¶é•¿ï¼Œéœ€è¦å‹ç¼©é™éŸ³é—´éš™
    
    ç­–ç•¥ï¼š
    1. é¦–å…ˆå°è¯•å‹ç¼©é™éŸ³é—´éš™
    2. å¦‚æœé—´éš™ä¸è¶³ï¼Œåˆ™åŠ é€Ÿæ¯æ®µé…éŸ³
    3. ç¡®ä¿æœ€ç»ˆæ€»æ—¶é•¿ = åŸå§‹æ€»æ—¶é•¿
    """
    # è®¡ç®—åŸå§‹é—´éš™
    gaps = []
    for i in range(len(self.subtitles)):
        if i == 0:
            gap = self.subtitles[i]['start_ms']
        else:
            gap = self.subtitles[i]['start_ms'] - self.subtitles[i-1]['end_ms']
        gaps.append(max(0, gap))
    
    total_gap = sum(gaps)
    print(f"  åŸå§‹é—´éš™æ€»æ—¶é•¿: {total_gap}ms")
    print(f"  éœ€è¦å‹ç¼©: {excess_time}ms")
    
    if total_gap >= excess_time:
        # é—´éš™è¶³å¤Ÿï¼ŒæŒ‰æ¯”ä¾‹å‹ç¼©
        print(f"  âœ… é—´éš™è¶³å¤Ÿï¼ŒæŒ‰æ¯”ä¾‹å‹ç¼©")
        compression_ratio = (total_gap - excess_time) / total_gap if total_gap > 0 else 0
        compressed_gaps = [int(gap * compression_ratio) for gap in gaps]
        adjusted_durations = actual_durations  # ä¸éœ€è¦åŠ é€Ÿé…éŸ³
    else:
        # é—´éš™ä¸è¶³ï¼Œéœ€è¦åŠ é€Ÿé…éŸ³
        remaining_excess = excess_time - total_gap
        print(f"  âš ï¸ é—´éš™ä¸è¶³ï¼Œç§»é™¤æ‰€æœ‰é—´éš™åä»è¶…å‡º {remaining_excess}ms")
        print(f"  ğŸš€ éœ€è¦åŠ é€Ÿé…éŸ³ä»¥å‹ç¼© {remaining_excess}ms")
        
        compressed_gaps = [0] * len(gaps)  # ç§»é™¤æ‰€æœ‰é—´éš™
        
        # è®¡ç®—éœ€è¦çš„åŠ é€Ÿå€ç‡
        total_audio_duration = sum(actual_durations)
        target_audio_duration = total_audio_duration - remaining_excess
        speedup_ratio = total_audio_duration / target_audio_duration
        
        print(f"  ğŸ“Š é…éŸ³æ€»æ—¶é•¿: {total_audio_duration}ms")
        print(f"  ğŸ“Š ç›®æ ‡æ—¶é•¿: {target_audio_duration}ms")
        print(f"  ğŸ“Š åŠ é€Ÿå€ç‡: {speedup_ratio:.2f}x")
        
        # æŒ‰æ¯”ä¾‹åŠ é€Ÿæ¯æ®µé…éŸ³
        adjusted_durations = [int(duration / speedup_ratio) for duration in actual_durations]
    
    # é‡æ–°è®¡ç®—æ—¶é—´è½´
    current_time = 0
    updated_subtitles = []
    
    for i, (subtitle, duration, gap) in enumerate(zip(self.subtitles, adjusted_durations, compressed_gaps)):
        current_time += gap
        
        updated_subtitle = subtitle.copy()
        updated_subtitle['start_ms'] = current_time
        updated_subtitle['end_ms'] = current_time + duration
        updated_subtitle['original_duration_ms'] = actual_durations[i]  # ä¿å­˜åŸå§‹æ—¶é•¿
        updated_subtitle['adjusted_duration_ms'] = duration  # ä¿å­˜è°ƒæ•´åæ—¶é•¿
        updated_subtitles.append(updated_subtitle)
        
        current_time += duration
        
        if actual_durations[i] != duration:
            print(f"  å­—å¹• {i+1}: {updated_subtitle['start_ms']}ms - {updated_subtitle['end_ms']}ms "
                  f"(åŸæ—¶é•¿: {actual_durations[i]}ms, åŠ é€Ÿå: {duration}ms)")
        else:
            print(f"  å­—å¹• {i+1}: {updated_subtitle['start_ms']}ms - {updated_subtitle['end_ms']}ms")
    
    final_time = current_time
    print(f"\n  æœ€ç»ˆæ€»æ—¶é•¿: {final_time}ms (ç›®æ ‡: {self.original_total_time}ms)")
    print(f"  è¯¯å·®: {final_time - self.original_total_time:+d}ms")
    
    return updated_subtitles
```

### ä¿®å¤ _merge_audio_with_timeline

```python
def _merge_audio_with_timeline(self, updated_subtitles, audio_files):
    """
    æ ¹æ®æ›´æ–°åçš„æ—¶é—´è½´åˆå¹¶éŸ³é¢‘
    
    Args:
        updated_subtitles: æ›´æ–°åçš„å­—å¹•åˆ—è¡¨ï¼ˆåŒ…å«æ–°çš„start_mså’Œend_msï¼‰
        audio_files: é…éŸ³æ–‡ä»¶åˆ—è¡¨
        
    Returns:
        æœ€ç»ˆéŸ³é¢‘æ–‡ä»¶è·¯å¾„
    """
    print("\nğŸ”— æ ¹æ®åŠ¨æ€æ—¶é—´è½´åˆå¹¶éŸ³é¢‘...")
    
    audio_segments = []
    current_time = 0
    
    # åˆ›å»ºä¸´æ—¶ç›®å½•ç”¨äºå­˜æ”¾åŠ é€Ÿåçš„éŸ³é¢‘
    speedup_temp_dir = self.temp_dir / "speedup"
    speedup_temp_dir.mkdir(parents=True, exist_ok=True)
    
    for i, subtitle in enumerate(updated_subtitles):
        # æ·»åŠ å­—å¹•å‰çš„é™éŸ³é—´éš™
        if subtitle['start_ms'] > current_time:
            gap = subtitle['start_ms'] - current_time
            print(f"  å­—å¹• {i+1} å‰æ·»åŠ é™éŸ³: {gap}ms")
            audio_segments.append(AudioSegment.silent(duration=gap))
            current_time += gap
        
        # åŠ è½½é…éŸ³éŸ³é¢‘
        audio_file = audio_files[i] if i < len(audio_files) else None
        if audio_file and os.path.exists(audio_file):
            try:
                audio = AudioSegment.from_file(audio_file)
                audio_duration = len(audio)
                
                # è®¡ç®—ç›®æ ‡æ—¶é•¿
                target_duration = subtitle['end_ms'] - subtitle['start_ms']
                
                # æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ é€Ÿï¼ˆä½¿ç”¨ original_duration_ms å’Œ adjusted_duration_msï¼‰
                original_duration = subtitle.get('original_duration_ms', audio_duration)
                adjusted_duration = subtitle.get('adjusted_duration_ms', target_duration)
                
                # å¦‚æœè°ƒæ•´åæ—¶é•¿ < åŸå§‹æ—¶é•¿ï¼Œè¯´æ˜éœ€è¦åŠ é€Ÿ
                if original_duration > adjusted_duration and abs(original_duration - adjusted_duration) > 10:
                    speed_ratio = original_duration / adjusted_duration
                    print(f"  å­—å¹• {i+1}: åŠ é€ŸéŸ³é¢‘ {speed_ratio:.2f}x ({original_duration}ms -> {adjusted_duration}ms)")
                    
                    # ä½¿ç”¨FFmpegåŠ é€Ÿ
                    speedup_output = speedup_temp_dir / f"speedup_{i:04d}.wav"
                    if self._speedup_audio_ffmpeg(audio_file, str(speedup_output), speed_ratio, adjusted_duration):
                        # åŠ é€ŸæˆåŠŸï¼ŒåŠ è½½åŠ é€Ÿåçš„éŸ³é¢‘
                        audio = AudioSegment.from_file(str(speedup_output))
                        print(f"    âœ… åŠ é€ŸæˆåŠŸï¼Œå®é™…æ—¶é•¿: {len(audio)}ms")
                    else:
                        # åŠ é€Ÿå¤±è´¥ï¼Œä½¿ç”¨pydubçš„speedupä½œä¸ºå¤‡é€‰
                        print(f"    âš ï¸ FFmpegåŠ é€Ÿå¤±è´¥ï¼Œä½¿ç”¨pydubå¤‡é€‰æ–¹æ¡ˆ")
                        audio = audio.speedup(playback_speed=speed_ratio)
                
                # ç¡®ä¿éŸ³é¢‘æ—¶é•¿åŒ¹é…ç›®æ ‡æ—¶é•¿
                actual_audio_duration = len(audio)
                if abs(actual_audio_duration - target_duration) > 10:
                    if actual_audio_duration > target_duration:
                        # éŸ³é¢‘ä»ç„¶å¤ªé•¿ï¼Œæˆªæ–­
                        audio = audio[:target_duration]
                        print(f"    âš ï¸ éŸ³é¢‘ä»ç„¶å¤ªé•¿ï¼Œæˆªæ–­åˆ° {target_duration}ms")
                    else:
                        # éŸ³é¢‘å¤ªçŸ­ï¼Œæ·»åŠ å°¾éƒ¨é™éŸ³
                        padding = target_duration - actual_audio_duration
                        audio = audio + AudioSegment.silent(duration=padding)
                        print(f"    âš ï¸ éŸ³é¢‘å¤ªçŸ­ï¼Œæ·»åŠ å°¾éƒ¨é™éŸ³ {padding}ms")
                
                audio_segments.append(audio)
                current_time += len(audio)
                print(f"  å­—å¹• {i+1}: æ·»åŠ é…éŸ³ {len(audio)}ms")
                
            except Exception as e:
                print(f"  âš ï¸ å­—å¹• {i+1} åŠ è½½éŸ³é¢‘å¤±è´¥: {e}ï¼Œä½¿ç”¨é™éŸ³")
                silence_duration = subtitle['end_ms'] - subtitle['start_ms']
                audio_segments.append(AudioSegment.silent(duration=silence_duration))
                current_time += silence_duration
        else:
            # ä½¿ç”¨é™éŸ³å¡«å……
            silence_duration = subtitle['end_ms'] - subtitle['start_ms']
            print(f"  å­—å¹• {i+1}: ä½¿ç”¨é™éŸ³å¡«å…… {silence_duration}ms")
            audio_segments.append(AudioSegment.silent(duration=silence_duration))
            current_time += silence_duration
    
    # åˆå¹¶æ‰€æœ‰éŸ³é¢‘ç‰‡æ®µ
    print(f"\n  ğŸ”— åˆå¹¶ {len(audio_segments)} ä¸ªéŸ³é¢‘ç‰‡æ®µ...")
    final_audio = sum(audio_segments)
    
    # å¯¼å‡ºæœ€ç»ˆéŸ³é¢‘
    output_path = self.output_dir / "dubbing_result.wav"
    print(f"  ğŸ’¾ å¯¼å‡ºæœ€ç»ˆéŸ³é¢‘: {output_path}")
    final_audio.export(str(output_path), format="wav")
    
    print(f"  âœ… æœ€ç»ˆéŸ³é¢‘æ—¶é•¿: {len(final_audio)}ms ({len(final_audio)/1000:.1f}ç§’)")
    
    return str(output_path)
```

## ğŸ“Š é¢„æœŸæ•ˆæœ

ä¿®å¤åï¼Œå¯ç”¨"ä¿æŒæ€»æ—¶é•¿ä¸å˜"æ—¶ï¼š

```
åŸå§‹SRTæ€»æ—¶é•¿: 115000ms (1:55)
é…éŸ³æ€»æ—¶é•¿: 152000ms (2:32)
è¶…å‡ºæ—¶é•¿: 37000ms

å¤„ç†æµç¨‹ï¼š
1. ç§»é™¤æ‰€æœ‰é™éŸ³é—´éš™ï¼ˆå‡è®¾æœ‰ 5000msï¼‰
2. ä»è¶…å‡º 32000ms
3. è®¡ç®—åŠ é€Ÿå€ç‡: 152000 / 120000 = 1.27x
4. åŠ é€Ÿæ¯æ®µé…éŸ³
5. æœ€ç»ˆè¾“å‡º: 115000ms (1:55) âœ…

è¾“å‡ºæ–‡ä»¶ï¼š
- adjusted_subtitles.srt (æ€»æ—¶é•¿ 1:55)
- dubbing_result.wav (æ€»æ—¶é•¿ 1:55)
```

## ğŸ¯ å»ºè®®

å¦‚æœä½ çš„éœ€æ±‚æ˜¯ç®€å•çš„é¡ºåºæ’åˆ—ï¼ˆä»æŒ‡å®šåç§»å¼€å§‹ï¼‰ï¼Œå»ºè®®ä½¿ç”¨ `SimpleTimelineBuilder`ï¼š

```python
# åœ¨ tts_dubbing_processor.py ä¸­
if self.use_simple_timeline:
    builder = SimpleTimelineBuilder(
        subtitles=subtitle_data,
        audio_files=audio_files,
        start_offset_ms=self.timeline_start_offset_ms,
        max_total_time_ms=self.max_video_duration_ms,
        max_speedup_rate=self.max_audio_speed_rate
    )
    updated_subtitles = builder.build_timeline()
    output_path = self._merge_audio_simple(updated_subtitles)
```

è¿™æ ·æ›´ç®€å•ã€æ›´ç›´æ¥ï¼Œä¸éœ€è¦å¤æ‚çš„é—´éš™å‹ç¼©é€»è¾‘ã€‚
