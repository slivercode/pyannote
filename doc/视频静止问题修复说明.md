# 视频静止问题修复说明

## 🐛 问题描述

**用户反馈**：执行视频合并后，视频画面静止了

**原因分析**：
- 之前的实现使用`loop`滤镜来延长视频
- `loop`滤镜会循环播放最后一帧
- 导致视频播放到最后时画面静止不动

## ✅ 修复方案

### 1. 移除视频延长逻辑

**之前的做法**：
```bash
# 当TTS音轨45秒，原视频30秒时
ffmpeg -i video.mp4 -i audio.wav \
  -filter_complex "[0:v]loop=loop=-1:size=1:start=0,trim=duration=45[vout]" \
  -map "[vout]" -map "1:a" \
  -c:v libx264 -c:a aac output.mp4

# 结果：视频延长到45秒，但30秒后画面静止（循环最后一帧）
```

**现在的做法**：
```bash
# 当TTS音轨45秒，原视频30秒时
ffmpeg -i video.mp4 -i audio.wav \
  -map "0:v" -map "1:a" \
  -c:v copy -c:a aac output.mp4

# 结果：
# - 视频正常播放30秒
# - 音轨完整播放45秒
# - 视频结束后显示黑屏，音轨继续播放
```

### 2. 核心改进

#### 改进1：视频正常播放
```python
# 不再使用loop滤镜延长视频
# 视频保持原长度，正常播放

if has_subtitle:
    # 仅烧录字幕，不延长视频
    video_filter = f"[0:v]subtitles='{subtitle_path_str}'[vout]"
else:
    # 正常映射视频流
    cmd.extend(["-map", "0:v"])
```

#### 改进2：音轨完整播放
```python
# 移除 -shortest 参数
# 确保音轨完整播放，不被截断

cmd.extend([
    "-map", "0:v",  # 视频流
    "-map", "1:a",  # 音频流（完整播放）
    "-c:v", "copy" if not has_subtitle else "libx264",
    "-c:a", "aac",
    str(output_path)
])
# 不添加 -shortest 参数
```

#### 改进3：友好提示
```python
if audio_duration > video_duration + 0.1:
    print(f"⚠️ 注意：音轨({audio_duration:.2f}秒)比视频({video_duration:.2f}秒)长")
    print(f"   视频将正常播放，音轨会完整播放")
    print(f"   视频播放完后会显示黑屏，但音轨继续播放")
```

## 🎯 推荐解决方案

### 方案A：使用TTS配音模块的时长控制功能

**最佳实践**：在TTS配音阶段就控制好时长

```
步骤1：TTS配音
1. 上传原视频的SRT字幕
2. 启用"保持SRT总时长不变"功能
3. 设置最大加速倍率（推荐1.5x-2.0x）
4. 生成TTS音轨

结果：TTS音轨时长 = 原视频时长

步骤2：视频合并
1. 上传原视频
2. 上传TTS音轨（时长已匹配）
3. 上传字幕文件
4. 选择"替换音轨 + 烧录字幕"
5. 开始合并

结果：
✅ 音视频时长完全一致
✅ 无黑屏问题
✅ 视频正常播放
✅ 字幕完美同步
```

### 方案B：接受黑屏（适用于音频内容为主的场景）

**适用场景**：
- 播客、有声书等音频内容为主
- 视频仅作为封面或背景
- 不介意视频结束后的黑屏

**操作**：
- 直接上传视频和音频
- 系统会自动处理
- 视频正常播放，音轨完整播放

## 📊 对比分析

### 之前的实现（v1.1.0）

| 场景 | 视频表现 | 音频表现 | 问题 |
|------|---------|---------|------|
| 音轨较长 | 延长到音轨长度 | 完整播放 | ❌ 画面静止 |
| 音轨较短 | 保持原长度 | 播放后静音 | ✅ 正常 |

### 现在的实现（v1.3.0）

| 场景 | 视频表现 | 音频表现 | 问题 |
|------|---------|---------|------|
| 音轨较长 | 保持原长度 | 完整播放 | ⚠️ 视频结束后黑屏 |
| 音轨较短 | 保持原长度 | 播放后静音 | ✅ 正常 |

### 推荐方案（使用TTS时长控制）

| 场景 | 视频表现 | 音频表现 | 问题 |
|------|---------|---------|------|
| 时长匹配 | 正常播放 | 完整播放 | ✅ 完美 |

## 🔧 技术细节

### 修改的文件

1. **src/scripts/video_merger.py**
   - `_replace_audio()` 方法
   - `_mix_audio()` 方法
   - `_embed_subtitle()` 方法

2. **doc/视频合并集成说明.md**
   - 更新技术实现说明
   - 添加使用建议

3. **doc/视频合并快速指南.md**
   - 更新使用场景
   - 添加推荐工作流程
   - 详细的故障排除

### 关键代码变更

**之前**：
```python
if need_extend:
    # 延长视频
    video_filter = f"[0:v]loop=loop=-1:size=1:start=0,trim=duration={audio_duration}[vout]"
    cmd.extend(["-filter_complex", video_filter])
```

**现在**：
```python
# 不延长视频，保持原长度
if has_subtitle:
    # 仅烧录字幕
    video_filter = f"[0:v]subtitles='{subtitle_path_str}'[vout]"
else:
    # 正常映射
    cmd.extend(["-map", "0:v"])
```

## 💡 使用建议

### 1. 最佳实践（推荐）

```
使用TTS配音模块的"保持SRT总时长不变"功能
→ TTS音轨时长自动匹配原视频
→ 视频合并时无黑屏问题
→ 完美的音视频同步
```

### 2. 快速方案

```
接受视频结束后的黑屏
→ 适用于音频内容为主的场景
→ 无需额外处理
→ 音轨完整播放
```

### 3. 手动调整

```
使用音频编辑软件调整TTS音轨时长
→ 加速或裁剪音轨
→ 使其与视频时长匹配
→ 然后进行视频合并
```

## 📋 测试验证

### 测试场景1：时长匹配
```
输入：
- 视频：30秒
- 音轨：30秒
- 字幕：有

结果：
✅ 视频正常播放30秒
✅ 音轨完整播放30秒
✅ 字幕正确显示
✅ 无黑屏问题
```

### 测试场景2：音轨较长
```
输入：
- 视频：30秒
- 音轨：45秒
- 字幕：有

结果：
✅ 视频正常播放30秒（不静止）
✅ 音轨完整播放45秒
✅ 字幕正确显示
⚠️ 30秒后显示黑屏，音轨继续播放
```

### 测试场景3：音轨较短
```
输入：
- 视频：45秒
- 音轨：30秒
- 字幕：有

结果：
✅ 视频正常播放45秒
✅ 音轨播放30秒后静音
✅ 字幕正确显示
✅ 无问题
```

## 🎓 总结

### 问题根源
- 使用`loop`滤镜延长视频导致画面静止

### 解决方案
- 移除视频延长逻辑
- 视频保持原长度正常播放
- 音轨完整播放不被截断

### 最佳实践
- 使用TTS配音模块的"保持SRT总时长"功能
- 在配音阶段就控制好时长
- 确保音视频时长匹配

### 用户体验
- ✅ 视频正常播放，不会静止
- ✅ 音轨完整播放，不被截断
- ✅ 字幕正确烧录和同步
- ⚠️ 如果音轨较长，视频结束后会黑屏（可通过TTS时长控制避免）
