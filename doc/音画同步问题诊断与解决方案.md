# 音画同步问题诊断与解决方案

> **📌 更新状态**：
> - ✅ 方案2.2：TTS时间轴验证已实现
> - ✅ 方案3.1：视频合并字幕调整验证已实现
> - ✅ 方案4.1：音频时长精确测量已实现
> - ✅ 方案5：综合同步验证工具已实现（`verify_sync.py`）
> - 📖 详细使用说明：[音画同步验证工具使用指南](./音画同步验证工具使用指南.md)

## 🎯 问题现象

TTS配音后，音频、视频、字幕三者存在不同步现象。

## 🔍 可能的原因分析

### 原因1：字幕时间轴生成不准确

**问题**：
- TTS生成的字幕时间轴与实际音频不匹配
- 启用"保持SRT总时长"导致时间轴被压缩/拉伸

**诊断方法**：
```bash
python diagnose_tts_timeline.py output/updated_subtitles.srt --audio output/dubbing_result.wav
```

**检查项**：
- 字幕总时长 vs 音频总时长
- 是否有大量静音间隙
- 字幕间隙分布是否合理

### 原因2：视频慢放后字幕未正确调整

**问题**：
- 视频被慢放以匹配音频
- 但字幕时间轴未相应调整
- 导致字幕和画面不对应

**检查项**：
- 视频慢放倍率
- 字幕是否也被调整了相同倍率
- 字幕烧录时间点是否正确

### 原因3：音频拼接时间轴计算错误

**问题**：
- TTS生成每段音频时长计算不准确
- 静音间隙添加位置错误
- 累积误差导致后面的字幕越来越不同步

**检查项**：
- 每段TTS音频的实际时长
- 静音间隙的实际时长
- 累积时间轴是否正确

### 原因4：FFmpeg处理导致的时间偏移

**问题**：
- 视频慢放时的时间戳计算误差
- 字幕烧录时的时间偏移
- 音频编码导致的微小时长变化

**检查项**：
- FFmpeg输出的实际时长
- 字幕烧录后的时间轴
- 音频编码前后的时长差异

## ✅ 解决方案

### 方案1：使用诊断脚本定位问题

**步骤**：
```bash
# 1. 诊断TTS生成的字幕和音频
python diagnose_tts_timeline.py output/updated_subtitles.srt --audio output/dubbing_result.wav

# 2. 检查视频合并后的结果
python diagnose_tts_timeline.py output/final_subtitles.srt --audio output/final_video.mp4
```

**根据诊断结果**：
- 如果字幕和音频不匹配 → 问题在TTS阶段
- 如果字幕和音频匹配，但和视频不匹配 → 问题在视频合并阶段

### 方案2：优化TTS时间轴生成

#### 2.1 关闭"保持SRT总时长"

**原理**：让字幕完全跟随音频，避免时间轴被压缩

**设置**：
```javascript
{
  "preserveTotalTime": false,  // 关闭
  "removeSilentGaps": true,    // 启用
  "silenceDuration": 0.5       // 0.5秒间隙
}
```

**效果**：
- 字幕时间轴 = 音频实际时长
- 无时间轴压缩/拉伸
- 字幕和音频完美匹配

#### 2.2 添加时间轴验证

**修改位置**：`src/scripts/tts_dubbing_processor.py`

**添加验证代码**：
```python
def _save_updated_srt(self, subtitles):
    """保存更新后的字幕文件，并验证时间轴"""
    output_srt = self.output_dir / "updated_subtitles.srt"
    
    # 保存字幕
    with open(output_srt, 'w', encoding='utf-8') as f:
        for i, subtitle in enumerate(subtitles):
            f.write(f"{i+1}\n")
            start_time = self._ms_to_srt_time(subtitle['start_ms'])
            end_time = self._ms_to_srt_time(subtitle['end_ms'])
            f.write(f"{start_time} --> {end_time}\n")
            f.write(f"{subtitle['text']}\n\n")
    
    # 验证时间轴
    print(f"\n📊 字幕时间轴验证:")
    total_subtitle_duration = sum(s['end_ms'] - s['start_ms'] for s in subtitles)
    total_timeline = subtitles[-1]['end_ms'] if subtitles else 0
    
    print(f"   字幕总数: {len(subtitles)}")
    print(f"   字幕总时长: {total_subtitle_duration/1000:.2f}秒")
    print(f"   时间轴总长: {total_timeline/1000:.2f}秒")
    print(f"   间隙总时长: {(total_timeline - total_subtitle_duration)/1000:.2f}秒")
    
    # 检查异常
    for i, sub in enumerate(subtitles):
        duration = sub['end_ms'] - sub['start_ms']
        if duration < 100:
            print(f"   ⚠️ 字幕{i+1}时长过短: {duration}ms")
        if i > 0:
            gap = sub['start_ms'] - subtitles[i-1]['end_ms']
            if gap < 0:
                print(f"   ⚠️ 字幕{i}和{i+1}重叠: {abs(gap)}ms")
            elif gap > 5000:
                print(f"   ⚠️ 字幕{i}和{i+1}间隙过大: {gap}ms")
    
    print(f"💾 保存更新后的字幕: {output_srt}")
    return str(output_srt)
```

### 方案3：优化视频合并时的字幕调整

#### 3.1 添加字幕调整验证

**修改位置**：`src/scripts/video_merger.py`

**在 `_adjust_subtitle_timeline` 方法中添加验证**：
```python
def _adjust_subtitle_timeline(self, subtitle_path: Path, stretch_ratio: float, output_path: Path) -> Path:
    """调整字幕时间轴以匹配视频慢放"""
    print(f"📝 调整字幕时间轴: 拉伸 {stretch_ratio:.3f}x")
    
    try:
        # 读取原始字幕
        with open(subtitle_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # 解析并调整SRT时间轴
        import re
        
        # 记录调整前后的时间戳（用于验证）
        adjustments = []
        
        def adjust_timestamp(match):
            time_str = match.group(0)
            parts = time_str.replace(',', ':').split(':')
            hours, minutes, seconds, milliseconds = map(int, parts)
            
            total_ms = (hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds
            new_total_ms = int(total_ms * stretch_ratio)
            
            # 记录调整
            adjustments.append((total_ms, new_total_ms))
            
            new_hours = new_total_ms // 3600000
            new_minutes = (new_total_ms % 3600000) // 60000
            new_seconds = (new_total_ms % 60000) // 1000
            new_milliseconds = new_total_ms % 1000
            
            return f"{new_hours:02d}:{new_minutes:02d}:{new_seconds:02d},{new_milliseconds:03d}"
        
        pattern = r'\d{2}:\d{2}:\d{2},\d{3}'
        adjusted_content = re.sub(pattern, adjust_timestamp, content)
        
        # 保存调整后的字幕
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(adjusted_content)
        
        # 验证调整
        print(f"✅ 字幕时间轴已调整:")
        print(f"   调整的时间戳数量: {len(adjustments)}")
        if adjustments:
            print(f"   第一个时间戳: {adjustments[0][0]/1000:.2f}s → {adjustments[0][1]/1000:.2f}s")
            print(f"   最后时间戳: {adjustments[-1][0]/1000:.2f}s → {adjustments[-1][1]/1000:.2f}s")
        print(f"   保存到: {output_path}")
        
        return output_path
        
    except Exception as e:
        print(f"⚠️ 字幕时间轴调整失败: {e}")
        import traceback
        traceback.print_exc()
        return subtitle_path
```

### 方案4：添加音频时长精确测量

#### 4.1 在TTS生成时精确测量每段音频

**修改位置**：`src/scripts/tts_dubbing_processor.py`

**在音频拼接时添加验证**：
```python
def _merge_audio_segments(self, audio_files, subtitles):
    """拼接音频片段，并验证时长"""
    print(f"\n🔗 拼接音频片段...")
    
    combined = AudioSegment.empty()
    current_time = 0
    
    for i, (audio_file, subtitle) in enumerate(zip(audio_files, subtitles)):
        # 加载音频
        audio = AudioSegment.from_file(audio_file)
        actual_duration = len(audio)
        expected_duration = subtitle['end_ms'] - subtitle['start_ms']
        
        # 验证时长
        diff = abs(actual_duration - expected_duration)
        if diff > 100:  # 超过100ms差异
            print(f"   ⚠️ 字幕{i+1}时长不匹配:")
            print(f"      预期: {expected_duration}ms")
            print(f"      实际: {actual_duration}ms")
            print(f"      差异: {diff}ms")
        
        # 添加音频
        combined += audio
        current_time += actual_duration
        
        # 添加静音间隙
        if i < len(audio_files) - 1:
            gap_duration = subtitles[i+1]['start_ms'] - subtitle['end_ms']
            if gap_duration > 0:
                silence = AudioSegment.silent(duration=gap_duration)
                combined += silence
                current_time += gap_duration
                print(f"   ⏸️  添加静音: {gap_duration}ms")
    
    # 验证总时长
    final_duration = len(combined)
    expected_total = subtitles[-1]['end_ms'] if subtitles else 0
    
    print(f"\n📊 音频拼接验证:")
    print(f"   预期总时长: {expected_total/1000:.2f}秒")
    print(f"   实际总时长: {final_duration/1000:.2f}秒")
    print(f"   差异: {abs(final_duration - expected_total)/1000:.2f}秒")
    
    return combined
```

### 方案5：添加全局同步验证工具

**✅ 已实现**：创建了综合验证脚本 `verify_sync.py`

**使用方法**：

```bash
# 检查音频和字幕（TTS生成后）
python verify_sync.py --audio output/dubbing_result.wav --subtitle output/updated_subtitles.srt

# 检查视频、音频和字幕（视频合并后）
python verify_sync.py --video output/final_video.mp4 --audio output/dubbing_result.wav --subtitle output/updated_subtitles.srt
```

**功能**：
- ✅ 同时检查视频、音频、字幕的时长
- ✅ 对比三者之间的差异
- ✅ 抽样检查关键时间点的字幕内容
- ✅ 提供针对性的修复建议

详细使用说明请参考：[音画同步验证工具使用指南](./音画同步验证工具使用指南.md)

## 🎯 推荐实施顺序

### 第一步：诊断问题

```bash
# 1. 诊断TTS输出
python diagnose_tts_timeline.py output/updated_subtitles.srt --audio output/dubbing_result.wav

# 2. 检查是否有明显问题
# - 字幕和音频时长差异 > 1秒
# - 大量静音间隙（> 5秒）
# - 字幕重叠或间隙异常
```

### 第二步：调整TTS设置

```javascript
// 推荐设置
{
  "preserveTotalTime": false,  // 关闭，让字幕跟随音频
  "removeSilentGaps": true,    // 启用，移除静音
  "silenceDuration": 0.5       // 0.5秒间隙
}
```

### 第三步：重新生成配音

使用新设置重新生成TTS配音，检查字幕和音频是否匹配。

### 第四步：视频合并

使用视频合并功能，系统会自动：
- 检测时长差异
- 慢放视频
- 调整字幕时间轴

### 第五步：验证结果

播放最终视频，检查：
- 字幕是否在正确的画面时刻显示
- 音频是否与画面同步
- 是否有明显的延迟或提前

## 🛠️ 快速修复建议

### 如果字幕比音频短

**原因**：启用了"保持SRT总时长"，字幕被压缩

**解决**：
1. 关闭"保持SRT总时长"
2. 重新生成配音

### 如果字幕比音频长

**原因**：添加了过多静音间隙

**解决**：
1. 启用"移除静音间隙"
2. 减小"静音间隔时长"（0.3-0.5秒）
3. 重新生成配音

### 如果字幕和音频匹配，但和视频不匹配

**原因**：视频慢放后字幕未调整

**解决**：
1. 检查视频合并日志，确认字幕是否被调整
2. 如果未调整，重新合并视频
3. 确保使用最新版本的video_merger.py

### 如果前面同步，后面越来越不同步

**原因**：累积误差

**解决**：
1. 检查每段TTS音频的实际时长
2. 添加时长验证代码（方案4）
3. 确保静音间隙计算准确

## 📊 预期效果

实施这些方案后：
- ✅ 字幕和音频完美匹配（误差 < 0.1秒）
- ✅ 视频和音频同步（误差 < 0.1秒）
- ✅ 字幕在正确的画面时刻显示
- ✅ 无明显的延迟或提前现象

---

**更新日期**: 2024-12-17  
**版本**: v1.5.0
